import pandas as pd
import json
from typing import Dict, List, Any, Optional
from flask import current_app
import pandasai as pai
from pandasai_litellm.litellm import LiteLLM
import matplotlib
matplotlib.use('Agg')  # Use non-interactive backend to avoid GUI issues

class QueryProcessor:
    def __init__(self):
        self.openai_api_key = None
        self.pandas_ai_configured = False
    
    def _get_openai_key(self):
        """Get OpenAI API key from current app context"""
        if not self.openai_api_key:
            try:
                self.openai_api_key = current_app.config.get('OPENAI_API_KEY')
            except RuntimeError:
                # Working outside of application context
                pass
        return self.openai_api_key
    
    def _configure_pandasai(self):
        """Configure PandasAI with LiteLLM"""
        if not self.pandas_ai_configured:
            api_key = self._get_openai_key()
            if api_key:
                try:
                    llm = LiteLLM(model="gpt-4o-mini", api_key=api_key)
                    pai.config.set({"llm": llm})
                    self.pandas_ai_configured = True
                    print("PandasAI configured successfully with LiteLLM")
                except Exception as e:
                    print(f"Failed to configure PandasAI with LiteLLM: {str(e)}")
                    return False
        return self.pandas_ai_configured
    
    def process_query(self, query: str, session_data: Dict) -> Dict[str, Any]:
        """
        Process a natural language query using PandasAI and return results
        """
        # Check if files are uploaded
        if 'uploaded_files' not in session_data or not session_data['uploaded_files']:
            return {
                'success': False,
                'error': 'No data uploaded. Please upload CSV files first.'
            }
        
        # Check if OpenAI is available
        if not self._get_openai_key():
            return {
                'success': False,
                'error': 'OpenAI API key not configured. Please set OPENAI_API_KEY in your environment.'
            }

        try:
            # Configure PandasAI
            if not self._configure_pandasai():
                return {
                    'success': False,
                    'error': 'Failed to configure PandasAI. Please check your OpenAI API key.'
                }
            
            # Process query with PandasAI using the new pattern
            result = self._process_with_pandasai_new(query, session_data)
            
            # Generate natural language report
            report = self._generate_report(query, result)
            
            return {
                'success': True,
                'result': result,
                'report': report,
                'pandas_code': 'Generated by PandasAI'  # PandasAI handles code generation internally
            }
            
        except Exception as e:
            print(f"Error in process_query: {str(e)}")
            return {
                'success': False,
                'error': f'Error processing query: {str(e)}'
            }
    
    def _process_with_pandasai_new(self, query: str, session_data: Dict) -> Dict[str, Any]:
        """Process query using PandasAI with the new pattern"""
        
        try:
            # Get the first uploaded file
            file_info = session_data['uploaded_files'][0]
            file_path = file_info['file_path']
            
            print(f"Processing query: '{query}' with file: {file_path}")
            
            # Use PandasAI's read_csv function
            df = pai.read_csv(file_path)
            print("Successfully loaded CSV with PandasAI")
            
            # Process the query using chat
            response = df.chat(query)
            print(f"PandasAI response type: {type(response)}")
            
            # Convert response to serializable format
            return self._convert_pandasai_response(response)
            
        except Exception as e:
            print(f"PandasAI new pattern failed: {str(e)}")
            # Fallback: try with pandas DataFrame if PandasAI read_csv fails
            try:
                print("Trying fallback with pandas DataFrame...")
                
                # Load with pandas and convert to PandasAI DataFrame
                file_info = session_data['uploaded_files'][0]
                file_path = file_info['file_path']
                
                # Load with pandas first
                pandas_df = pd.read_csv(file_path)
                print(f"Loaded pandas DataFrame with shape: {pandas_df.shape}")
                
                # Clean the dataframe
                pandas_df.columns = [str(col).strip().replace(' ', '_').replace('-', '_') for col in pandas_df.columns]
                pandas_df = pandas_df.dropna(how='all').dropna(axis=1, how='all')
                
                if len(pandas_df) == 0:
                    raise Exception("No valid data in the dataframe")
                
                # Convert to PandasAI DataFrame
                df = pai.DataFrame(pandas_df)
                print("Successfully converted to PandasAI DataFrame")
                
                # Process the query
                response = df.chat(query)
                print(f"Fallback response type: {type(response)}")
                print("Debugging response: ", response.value)
                
                return self._convert_pandasai_response(response)
                
            except Exception as e2:
                print(f"Fallback also failed: {str(e2)}")
                # Final fallback: return a basic response
                return {
                    'type': 'error',
                    'data': f"PandasAI processing failed. Please try rephrasing your query. Error: {str(e2)}"
                }
    
    def _convert_pandasai_response(self, response) -> Dict[str, Any]:
        """Convert PandasAI response to serializable format"""
        
        print(f"Converting response of type: {type(response)}")
        
        # Handle PandasAI DataFrameResponse type
        if hasattr(response, 'value') and hasattr(response, 'type'):
            # This is a PandasAI response object
            print(f"PandasAI response type: {response.type}")
            print(f"PandasAI response value type: {type(response.value)}")
            
            if response.type == "dataframe":
                # Extract the actual DataFrame from the response
                df = response.value
                if isinstance(df, pd.DataFrame):
                    # Convert datetime objects to strings for JSON serialization
                    df_copy = df.head(20).copy()
                    for col in df_copy.columns:
                        if df_copy[col].dtype == 'datetime64[ns]':
                            df_copy[col] = df_copy[col].dt.strftime('%Y-%m-%d')
                        elif df_copy[col].dtype == 'object':
                            df_copy[col] = df_copy[col].astype(str)
                    
                    return {
                        'type': 'dataframe',
                        'data': df_copy.to_dict('records'),
                        'columns': df.columns.tolist(),
                        'total_rows': len(df),
                        'shape': df.shape
                    }
                else:
                    return {
                        'type': 'other',
                        'data': str(df)
                    }
            elif response.type == "series":
                series = response.value
                if isinstance(series, pd.Series):
                    series_copy = series.copy()
                    if series_copy.dtype == 'datetime64[ns]':
                        series_copy = series_copy.dt.strftime('%Y-%m-%d')
                    elif series_copy.dtype == 'object':
                        series_copy = series_copy.astype(str)
                    
                    return {
                        'type': 'series',
                        'data': series_copy.to_dict(),
                        'index': series.index.tolist(),
                        'dtype': str(series.dtype)
                    }
                else:
                    return {
                        'type': 'other',
                        'data': str(series)
                    }
            elif response.type == "number":
                # Convert numpy types to Python native types for JSON serialization
                value = response.value
                if hasattr(value, 'item'):  # numpy scalar
                    value = value.item()
                return {
                    'type': 'scalar',
                    'value': value
                }
            elif response.type == "string":
                return {
                    'type': 'scalar',
                    'value': response.value
                }
            elif response.type == "chart":
                # Handle PandasAI chart response
                print("Processing PandasAI chart response")
                chart_value = response.value
                
                # Check if PandasAI generated a PNG file
                import os
                import glob
                
                # Look for the most recent PNG file in exports/charts/
                chart_dir = "exports/charts"
                if os.path.exists(chart_dir):
                    png_files = glob.glob(os.path.join(chart_dir, "*.png"))
                    if png_files:
                        # Get the most recent PNG file
                        latest_png = max(png_files, key=os.path.getctime)
                        print(f"Found chart PNG: {latest_png}")
                        
                        # Return just the filename for the PNG file
                        filename = os.path.basename(latest_png)
                        print(f"Returning PNG chart filename: {filename}")
                        return {
                            'type': 'chart',
                            'chart': {
                                'image_path': filename,
                                'chart_type': 'png'
                            },
                            'chart_type': 'png'
                        }
                
                # Fallback: try to handle as Plotly figure
                if hasattr(chart_value, 'to_json'):
                    # It's a Plotly figure
                    chart_json = json.loads(chart_value.to_json())
                    return {
                        'type': 'chart',
                        'chart': {
                            'data': chart_json,
                            'chart_type': 'plotly'
                        },
                        'chart_type': 'plotly'
                    }
                else:
                    # Fallback for other chart types
                    return {
                        'type': 'chart',
                        'chart': {
                            'data': str(chart_value),
                            'chart_type': 'unknown'
                        },
                        'chart_type': 'unknown'
                    }
            else:
                return {
                    'type': 'other',
                    'data': str(response.value)
                }
        
        # Handle direct pandas objects (fallback)
        elif isinstance(response, pd.DataFrame):
            # Convert datetime objects to strings for JSON serialization
            df_copy = response.head(20).copy()
            for col in df_copy.columns:
                if df_copy[col].dtype == 'datetime64[ns]':
                    df_copy[col] = df_copy[col].dt.strftime('%Y-%m-%d')
                elif df_copy[col].dtype == 'object':
                    df_copy[col] = df_copy[col].astype(str)
            
            return {
                'type': 'dataframe',
                'data': df_copy.to_dict('records'),
                'columns': response.columns.tolist(),
                'total_rows': len(response),
                'shape': response.shape
            }
        elif isinstance(response, pd.Series):
            # Convert datetime objects to strings for JSON serialization
            series_copy = response.copy()
            if series_copy.dtype == 'datetime64[ns]':
                series_copy = series_copy.dt.strftime('%Y-%m-%d')
            elif series_copy.dtype == 'object':
                series_copy = series_copy.astype(str)
            
            return {
                'type': 'series',
                'data': series_copy.to_dict(),
                'index': response.index.tolist(),
                'dtype': str(response.dtype)
            }
        elif isinstance(response, (int, float, str, bool)):
            # Convert numpy types to Python native types for JSON serialization
            value = response
            if hasattr(value, 'item'):  # numpy scalar
                value = value.item()
            return {
                'type': 'scalar',
                'value': value
            }
        elif isinstance(response, dict):
            return {
                'type': 'dict',
                'data': {k: str(v) if isinstance(v, (pd.DataFrame, pd.Series)) else v 
                        for k, v in response.items()}
            }
        else:
            return {
                'type': 'other',
                'data': str(response)
            }
    
    def _generate_report(self, query: str, result: Dict) -> str:
        """Generate natural language report from query results"""
        
        print(f"Generating report for result type: {result.get('type', 'unknown')}")
        
        # Create a simple report based on the result type
        if result['type'] == 'dataframe':
            rows = result.get('total_rows', 0)
            cols = len(result.get('columns', []))
            return f"Analysis completed successfully. Found {rows} records with {cols} columns. The data has been processed and is ready for review."
        
        elif result['type'] == 'scalar':
            value = result.get('value', 'unknown')
            return f"Query result: {value}"
        
        elif result['type'] == 'series':
            data = result.get('data', {})
            count = len(data)
            return f"Analysis completed. Found {count} data points in the series."
        
        elif result['type'] == 'dict':
            data = result.get('data', {})
            count = len(data)
            return f"Analysis completed. Generated {count} key-value pairs."
        
        elif result['type'] == 'chart':
            chart_type = result.get('chart_type', 'chart')
            return f"Chart generated successfully. The {chart_type} visualization is ready for review."
        
        elif result['type'] == 'error':
            return f"Analysis failed: {result.get('data', 'Unknown error')}"
        
        else:
            return f"Analysis completed successfully. Results are available for review." 
    
     